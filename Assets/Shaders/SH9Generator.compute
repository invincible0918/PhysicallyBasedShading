// Spherical harmonic illumination parameters are extracted from CubeMap 
// By using spherical uniform sampling

#include "SH9Common.hlsl"
#include "HelperFunction.hlsl"

#pragma kernel CSMain
#pragma multi_compile __ _HDR

#define THREAD_X 8
#define THREAD_Y 8
#define SH_DEGREE 3

static uint ShcCount = SH_DEGREE * SH_DEGREE;

TextureCube<float4> _Cubemap;
//SamplerState Sampler_LinearClamp;
SamplerState Sampler_PointClamp;
uint2 _SampleSize;

// Each ThreadGroup will save the sum result in buffer in the bias position
// Each size of ThreadGroup is shcCount (SH_DEGREE * SH_DEGREE) * float4
RWStructuredBuffer<float4> _ShcBuffer;

// It stores the result of each thread calculation, the array size is 8*8*9=576
groupshared float4 ShcGroup[THREAD_X * THREAD_Y * SH_DEGREE * SH_DEGREE];

// groupIndex is the index of current thread in the thread group
// https://zhuanlan.zhihu.com/p/363936187
void CalculateSH9(float theta, float phi, uint groupIndex)
{
    float3 localSpaceDir = LocalSpaceDirection(theta, phi);
    float4 rgbm = _Cubemap.SampleLevel(Sampler_PointClamp, localSpaceDir, 1);

    float4 color = 1;
#if defined(_HDR)
    color.rgb = LinearToGammaSpace(rgbm.rgb);
#else
    color.rgb = rgbm.rgb;
#endif

    uint N = _SampleSize.x * _SampleSize.y;
    float A = 4 * PI / N;
    uint groupOffset = groupIndex * ShcCount;

    ShcGroup[groupOffset + 0] = color * GetY00(theta, phi) * A;
    ShcGroup[groupOffset + 1] = color * GetY1n1(theta, phi) * A;
    ShcGroup[groupOffset + 2] = color * GetY10(theta, phi) * A;
    ShcGroup[groupOffset + 3] = color * GetY1p1(theta, phi) * A;
    ShcGroup[groupOffset + 4] = color * GetY2n2(theta, phi) * A;
    ShcGroup[groupOffset + 5] = color * GetY2n1(theta, phi) * A;
    ShcGroup[groupOffset + 6] = color * GetY20(theta, phi) * A;
    ShcGroup[groupOffset + 7] = color * GetY2p1(theta, phi) * A;
    ShcGroup[groupOffset + 8] = color * GetY2p2(theta, phi) * A;
}

[numthreads(THREAD_X, THREAD_Y, 1)]
void CSMain (uint3 groupID : SV_GroupID, uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
    ////_pixel = id.xy;
    ////SetSeed();

    //// uniform sampling
    float theta, phi;
    //UniformSampling(/*out */theta, /*out */phi);
    theta = acos(1 - id.x * 2.0 / (_SampleSize.x - 1));
    phi = 2 * PI * (id.y * 1.0 / (_SampleSize.y - 1));

    CalculateSH9(theta, phi, groupIndex);
    GroupMemoryBarrierWithGroupSync();
    uint threadCount = THREAD_X * THREAD_Y;
    for (uint k = (threadCount >> 1); k > 0; k >>= 1) 
    {
        if (groupIndex < k)
        {
            uint shIndex = groupIndex * ShcCount;
            uint shIndex2 = (groupIndex + k) * ShcCount;
            for (uint offset = 0; offset < ShcCount; offset++) {
                ShcGroup[shIndex + offset] += ShcGroup[shIndex2 + offset];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if (groupIndex == 0) 
    {
        uint groupCountX = _SampleSize.x / THREAD_X;
        uint index = (groupID.y * groupCountX + groupID.x) * ShcCount;
        for (uint i = 0; i < ShcCount; i++) {
            float4 c = ShcGroup[i];
            _ShcBuffer[index + i] = c;
        }
    }
}
